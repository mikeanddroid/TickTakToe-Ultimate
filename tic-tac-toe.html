<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
            margin: 0;
            color: white;
            overflow-x: hidden;
            transition: all 0.5s ease;
        }

        /* Dynamic backgrounds */
        .theme-space {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
        }

        .theme-ocean {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .theme-sunset {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
        }

        .theme-forest {
            background: linear-gradient(135deg, #134e5e 0%, #71b280 100%);
        }

        /* Animated background particles */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            animation: float 6s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.6; }
            50% { transform: translateY(-20px) rotate(180deg); opacity: 1; }
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 255, 0.3); }
            to { text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5), 0 0 30px rgba(255, 255, 255, 0.5); }
        }

        .controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .game-mode, .difficulty, .theme-selector, .tournament-controls, .player-names {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .player-names input {
            padding: 6px 12px;
            border: none;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 0.9rem;
            width: 100px;
            text-align: center;
        }

        .tournament-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 15px;
            margin-bottom: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .tournament-bracket {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .match {
            background: rgba(255, 255, 255, 0.15);
            padding: 0.5rem;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .match.completed {
            background: rgba(76, 175, 80, 0.3);
        }

        .match.current {
            background: rgba(255, 215, 61, 0.3);
            border: 2px solid rgba(255, 215, 61, 0.6);
        }

        .save-load-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 1rem;
        }

        .save-slot {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .save-slot input {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            padding: 4px 8px;
            color: #333;
            font-size: 0.8rem;
            width: 80px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: rgba(244, 67, 54, 0.9);
        }

        .notification.info {
            background: rgba(33, 150, 243, 0.9);
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn.active {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .game-area {
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 25px;
            backdrop-filter: blur(20px);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            gap: 2rem;
        }

        .score-board {
            display: flex;
            gap: 2rem;
            font-size: 1.1rem;
        }

        .score {
            text-align: center;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .current-player {
            font-size: 1.3rem;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            max-width: 360px;
            margin: 0 auto 2rem;
            perspective: 1000px;
        }

        .cell {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.4s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .cell:hover::before {
            left: 100%;
        }

        .cell:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: rotateY(10deg) scale(1.05);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .cell.taken {
            cursor: not-allowed;
            background: rgba(255, 255, 255, 0.3);
            animation: cellTaken 0.6s ease;
        }

        @keyframes cellTaken {
            0% { transform: scale(1) rotateZ(0deg); }
            50% { transform: scale(1.1) rotateZ(180deg); }
            100% { transform: scale(1) rotateZ(360deg); }
        }

        .cell.taken:hover {
            transform: none;
        }

        .cell.winning {
            animation: winningCell 1s ease infinite;
        }

        @keyframes winningCell {
            0%, 100% { 
                background: rgba(255, 215, 61, 0.4);
                box-shadow: 0 0 20px rgba(255, 215, 61, 0.6);
            }
            50% { 
                background: rgba(255, 215, 61, 0.6);
                box-shadow: 0 0 30px rgba(255, 215, 61, 0.8);
            }
        }

        .cell.preview {
            background: rgba(255, 255, 255, 0.3) !important;
            transform: scale(0.95);
            animation: previewPulse 0.6s ease infinite alternate;
        }

        @keyframes previewPulse {
            0% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .board.shake {
            animation: boardShake 0.5s ease;
        }

        @keyframes boardShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .ai-thinking-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            animation: aiThinking 1s ease infinite;
            pointer-events: none;
            z-index: 10;
        }

        @keyframes aiThinking {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0.8; }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(180deg); opacity: 1; }
        }

        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .confetti {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ffd93d;
            animation: confettiFall 3s linear infinite;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .score-animation {
            animation: scoreUpdate 0.8s ease;
        }

        @keyframes scoreUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #ffd93d; }
            100% { transform: scale(1); }
        }

        .difficulty .btn {
            position: relative;
            overflow: hidden;
        }

        .difficulty .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            transition: left 0.5s;
        }

        .difficulty .btn.active::after {
            left: 100%;
        }

        .move-trail {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 215, 61, 0.8), transparent);
            pointer-events: none;
            animation: trailFade 1s ease-out forwards;
        }

        @keyframes trailFade {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(3);
                opacity: 0;
            }
        }

        .x {
            color: #ff6b6b;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.8);
            animation: playerEntry 0.5s ease;
        }

        .o {
            color: #4ecdc4;
            text-shadow: 0 0 20px rgba(78, 205, 196, 0.8);
            animation: playerEntry 0.5s ease;
        }

        @keyframes playerEntry {
            0% { transform: scale(0) rotate(180deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .input-section {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            justify-content: center;
            align-items: center;
        }

        input[type="number"] {
            padding: 12px 18px;
            font-size: 1.2rem;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            text-align: center;
            width: 80px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .action-btn {
            padding: 12px 24px;
            font-size: 1.2rem;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        .reset-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }

        .reset-btn:hover {
            box-shadow: 0 8px 25px rgba(78, 205, 196, 0.4);
        }

        .game-result {
            font-size: 1.8rem;
            font-weight: bold;
            margin: 1rem 0;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
            animation: resultEntry 0.8s ease;
        }

        @keyframes resultEntry {
            0% { transform: scale(0) rotateY(180deg); opacity: 0; }
            100% { transform: scale(1) rotateY(0deg); opacity: 1; }
        }

        .winner {
            color: #ffd93d;
            text-shadow: 0 0 30px rgba(255, 217, 61, 0.8);
        }

        .draw {
            color: #ff9f43;
            text-shadow: 0 0 30px rgba(255, 159, 67, 0.8);
        }

        .thinking {
            color: #a8e6cf;
            font-size: 1.2rem;
            animation: thinking 1.5s ease infinite;
        }

        @keyframes thinking {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .combo-display {
            margin-top: 1rem;
            font-size: 1.1rem;
            color: #ffd93d;
            font-weight: bold;
        }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .board {
                max-width: 300px;
            }
            
            .cell {
                width: 80px;
                height: 80px;
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            h1 {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body class="theme-ocean">
    <div class="particles" id="particles"></div>
    
    <div class="game-container">
        <div class="header">
            <h1>🎯 Ultimate Tic-Tac-Toe 🎯</h1>
        </div>

        <div class="controls">
            <div class="game-mode">
                <span>Mode:</span>
                <button class="btn active" onclick="setGameMode('pvp')" id="btn-pvp">👥 2 Players</button>
                <button class="btn" onclick="setGameMode('ai')" id="btn-ai">🤖 vs AI</button>
                <button class="btn" onclick="setGameMode('tournament')" id="btn-tournament">🏆 Tournament</button>
            </div>
            
            <div class="difficulty" id="difficulty-section" style="display: none;">
                <span>AI:</span>
                <button class="btn" onclick="setDifficulty('easy')" id="btn-easy">😊 Easy</button>
                <button class="btn" onclick="setDifficulty('medium')" id="btn-medium">🤔 Medium</button>
                <button class="btn active" onclick="setDifficulty('hard')" id="btn-hard">😈 Hard</button>
                <button class="btn" onclick="setDifficulty('impossible')" id="btn-impossible">💀 Impossible</button>
            </div>

            <div class="player-names" id="player-names-section">
                <span>Names:</span>
                <input type="text" id="player-x-name" placeholder="Player X" maxlength="12">
                <input type="text" id="player-o-name" placeholder="Player O" maxlength="12">
            </div>
            
            <div class="tournament-controls" id="tournament-controls" style="display: none;">
                <span>Players:</span>
                <button class="btn" onclick="setTournamentSize(4)">4 Players</button>
                <button class="btn active" onclick="setTournamentSize(8)">8 Players</button>
                <button class="btn" onclick="startTournament()">🚀 Start</button>
            </div>
            
            <div class="theme-selector">
                <span>Theme:</span>
                <button class="btn" onclick="setTheme('ocean')">🌊</button>
                <button class="btn" onclick="setTheme('space')">🌌</button>
                <button class="btn" onclick="setTheme('sunset')">🌅</button>
                <button class="btn" onclick="setTheme('forest')">🌲</button>
            </div>
        </div>

        <div class="tournament-info" id="tournament-info" style="display: none;">
            <h3>🏆 Tournament Progress</h3>
            <div id="tournament-status">Ready to start tournament...</div>
            <div class="tournament-bracket" id="tournament-bracket"></div>
        </div>

        <div class="game-area">
            <div class="game-info">
                <div class="score-board">
                    <div class="score">
                        <div>Player X</div>
                        <div id="score-x">0</div>
                    </div>
                    <div class="score">
                        <div>Draws</div>
                        <div id="score-draw">0</div>
                    </div>
                    <div class="score">
                        <div id="player-o-label">Player O</div>
                        <div id="score-o">0</div>
                    </div>
                </div>
                
                <div class="current-player">
                    Current: <span id="current-player" class="x">X</span>
                    <div id="ai-thinking" class="thinking" style="display: none;">🤔 AI is thinking...</div>
                </div>
            </div>
            
            <div class="board" id="board">
                <div class="cell" data-index="0">1</div>
                <div class="cell" data-index="1">2</div>
                <div class="cell" data-index="2">3</div>
                <div class="cell" data-index="3">4</div>
                <div class="cell" data-index="4">5</div>
                <div class="cell" data-index="5">6</div>
                <div class="cell" data-index="6">7</div>
                <div class="cell" data-index="7">8</div>
                <div class="cell" data-index="8">9</div>
            </div>
            
            <div class="input-section">
                <input type="number" id="move-input" min="1" max="9" placeholder="1-9">
                <button class="action-btn" onclick="makeMove()">Make Move</button>
                <button class="action-btn reset-btn" onclick="resetGame()">🔄 New Game</button>
            </div>
            
            <div class="game-result" id="game-result"></div>
            <div class="combo-display" id="combo-display"></div>

            <div class="save-load-controls">
                <div class="save-slot">
                    <span>💾</span>
                    <input type="text" id="save-name" placeholder="Save name" maxlength="20">
                    <button class="btn" onclick="saveGame()">Save</button>
                </div>
                <div class="save-slot">
                    <span>📁</span>
                    <select id="load-select" onchange="loadGame()">
                        <option value="">Load game...</option>
                    </select>
                    <button class="btn" onclick="deleteSave()">🗑️</button>
                </div>
                <button class="btn" onclick="exportData()">📤 Export</button>
                <input type="file" id="import-file" accept=".json" style="display: none;" onchange="importData()">
                <button class="btn" onclick="document.getElementById('import-file').click()">📥 Import</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        let currentPlayer = 'X';
        let gameBoard = ['', '', '', '', '', '', '', '', ''];
        let gameActive = true;
        let gameMode = 'pvp'; // 'pvp', 'ai', or 'tournament'
        let aiDifficulty = 'hard'; // 'easy', 'medium', 'hard', or 'impossible'
        let scores = { x: 0, o: 0, draw: 0 };
        let moveCount = 0;
        let winningCombo = null;
        
        // Tournament variables
        let tournamentMode = false;
        let tournamentSize = 8;
        let tournamentPlayers = [];
        let tournamentMatches = [];
        let currentMatch = 0;
        let tournamentRound = 1;
        
        // Player names
        let playerNames = { x: 'Player X', o: 'Player O' };
        
        const winningConditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
            [0, 4, 8], [2, 4, 6] // diagonals
        ];

        // Create animated background particles
        function createParticles() {
            const particlesContainer = document.getElementById('particles');
            particlesContainer.innerHTML = '';
            
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.top = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 6 + 's';
                particle.style.animationDuration = (Math.random() * 3 + 3) + 's';
                particlesContainer.appendChild(particle);
            }
        }

        // Game mode functions
        function setGameMode(mode) {
            gameMode = mode;
            document.querySelectorAll('.game-mode .btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${mode}`).classList.add('active');
            
            const difficultySection = document.getElementById('difficulty-section');
            const tournamentControls = document.getElementById('tournament-controls');
            const tournamentInfo = document.getElementById('tournament-info');
            const playerOLabel = document.getElementById('player-o-label');
            
            // Hide all mode-specific sections
            difficultySection.style.display = 'none';
            tournamentControls.style.display = 'none';
            tournamentInfo.style.display = 'none';
            
            if (mode === 'ai') {
                difficultySection.style.display = 'flex';
                playerOLabel.textContent = 'AI';
                tournamentMode = false;
            } else if (mode === 'tournament') {
                tournamentControls.style.display = 'flex';
                tournamentInfo.style.display = 'block';
                playerOLabel.textContent = 'Player O';
                tournamentMode = true;
            } else {
                playerOLabel.textContent = 'Player O';
                tournamentMode = false;
            }
            
            resetGame();
        }

        function setDifficulty(difficulty) {
            aiDifficulty = difficulty;
            document.querySelectorAll('.difficulty .btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${difficulty}`).classList.add('active');
            resetGame();
        }

        function setTheme(theme) {
            document.body.className = `theme-${theme}`;
            document.querySelectorAll('.theme-selector .btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // Player name functions
        function updatePlayerNames() {
            const xName = document.getElementById('player-x-name').value.trim() || 'Player X';
            const oName = document.getElementById('player-o-name').value.trim() || 'Player O';
            
            playerNames.x = xName;
            playerNames.o = oName;
            
            // Update score display
            document.querySelector('.score:first-child div:first-child').textContent = xName;
            if (gameMode !== 'ai') {
                document.getElementById('player-o-label').textContent = oName;
            }
        }

        // Tournament functions
        function setTournamentSize(size) {
            tournamentSize = size;
            document.querySelectorAll('.tournament-controls .btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function startTournament() {
            if (tournamentSize < 4) {
                showNotification('Tournament needs at least 4 players!', 'error');
                return;
            }

            // Generate tournament players
            tournamentPlayers = [];
            for (let i = 1; i <= tournamentSize; i++) {
                tournamentPlayers.push(`Player ${i}`);
            }

            // Shuffle players
            for (let i = tournamentPlayers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tournamentPlayers[i], tournamentPlayers[j]] = [tournamentPlayers[j], tournamentPlayers[i]];
            }

            // Create initial matches
            tournamentMatches = [];
            currentMatch = 0;
            tournamentRound = 1;
            
            for (let i = 0; i < tournamentPlayers.length; i += 2) {
                tournamentMatches.push({
                    player1: tournamentPlayers[i],
                    player2: tournamentPlayers[i + 1],
                    winner: null,
                    round: tournamentRound
                });
            }

            updateTournamentDisplay();
            startNextMatch();
            showNotification(`🏆 Tournament started with ${tournamentSize} players!`, 'success');
        }

        function updateTournamentDisplay() {
            const bracket = document.getElementById('tournament-bracket');
            const status = document.getElementById('tournament-status');
            
            bracket.innerHTML = '';
            
            // Group matches by round
            const rounds = {};
            tournamentMatches.forEach(match => {
                if (!rounds[match.round]) rounds[match.round] = [];
                rounds[match.round].push(match);
            });

            Object.keys(rounds).forEach(round => {
                const roundDiv = document.createElement('div');
                roundDiv.innerHTML = `<h4>Round ${round}</h4>`;
                
                rounds[round].forEach((match, index) => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match';
                    
                    if (match.winner) {
                        matchDiv.classList.add('completed');
                    } else if (round == tournamentRound && index == currentMatch) {
                        matchDiv.classList.add('current');
                    }
                    
                    matchDiv.innerHTML = `
                        <div>${match.player1}</div>
                        <div>vs</div>
                        <div>${match.player2}</div>
                        ${match.winner ? `<div><strong>Winner: ${match.winner}</strong></div>` : ''}
                    `;
                    
                    roundDiv.appendChild(matchDiv);
                });
                
                bracket.appendChild(roundDiv);
            });

            if (tournamentMatches.length > 0) {
                const currentTournamentMatch = tournamentMatches.find(m => m.round === tournamentRound && !m.winner);
                if (currentTournamentMatch) {
                    status.textContent = `Round ${tournamentRound}: ${currentTournamentMatch.player1} vs ${currentTournamentMatch.player2}`;
                } else {
                    status.textContent = 'Tournament Complete!';
                }
            }
        }

        function startNextMatch() {
            const matches = tournamentMatches.filter(m => m.round === tournamentRound);
            const currentTournamentMatch = matches[currentMatch];
            
            if (!currentTournamentMatch) {
                // Round complete, advance to next round
                advanceToNextRound();
                return;
            }

            // Set current match players
            playerNames.x = currentTournamentMatch.player1;
            playerNames.o = currentTournamentMatch.player2;
            
            document.querySelector('.score:first-child div:first-child').textContent = playerNames.x;
            document.getElementById('player-o-label').textContent = playerNames.o;
            
            resetGame();
            updateTournamentDisplay();
        }

        function advanceToNextRound() {
            const currentRoundMatches = tournamentMatches.filter(m => m.round === tournamentRound);
            const winners = currentRoundMatches.map(m => m.winner).filter(w => w !== null);
            
            if (winners.length === 1) {
                // Tournament complete!
                showNotification(`🎉 Tournament Winner: ${winners[0]}!`, 'success');
                document.getElementById('tournament-status').textContent = `🏆 Champion: ${winners[0]}!`;
                return;
            }
            
            // Create next round matches
            tournamentRound++;
            currentMatch = 0;
            
            for (let i = 0; i < winners.length; i += 2) {
                tournamentMatches.push({
                    player1: winners[i],
                    player2: winners[i + 1],
                    winner: null,
                    round: tournamentRound
                });
            }
            
            startNextMatch();
        }

        // Save/Load functions
        function saveGame() {
            const saveName = document.getElementById('save-name').value.trim();
            if (!saveName) {
                showNotification('Please enter a save name!', 'error');
                return;
            }

            const gameState = {
                scores,
                playerNames,
                gameMode,
                aiDifficulty,
                tournamentData: tournamentMode ? {
                    tournamentSize,
                    tournamentPlayers,
                    tournamentMatches,
                    currentMatch,
                    tournamentRound
                } : null,
                timestamp: new Date().toISOString()
            };

            const saves = JSON.parse(localStorage.getItem('ticTacToeSaves') || '{}');
            saves[saveName] = gameState;
            localStorage.setItem('ticTacToeSaves', JSON.stringify(saves));

            updateLoadOptions();
            showNotification(`Game saved as "${saveName}"!`, 'success');
            document.getElementById('save-name').value = '';
        }

        function loadGame() {
            const saveName = document.getElementById('load-select').value;
            if (!saveName) return;

            const saves = JSON.parse(localStorage.getItem('ticTacToeSaves') || '{}');
            const gameState = saves[saveName];

            if (!gameState) {
                showNotification('Save file not found!', 'error');
                return;
            }

            // Restore game state
            scores = gameState.scores || { x: 0, o: 0, draw: 0 };
            playerNames = gameState.playerNames || { x: 'Player X', o: 'Player O' };
            
            // Restore UI
            document.getElementById('player-x-name').value = playerNames.x === 'Player X' ? '' : playerNames.x;
            document.getElementById('player-o-name').value = playerNames.o === 'Player O' ? '' : playerNames.o;
            
            setGameMode(gameState.gameMode || 'pvp');
            setDifficulty(gameState.aiDifficulty || 'hard');

            // Restore tournament if applicable
            if (gameState.tournamentData) {
                tournamentSize = gameState.tournamentData.tournamentSize;
                tournamentPlayers = gameState.tournamentData.tournamentPlayers;
                tournamentMatches = gameState.tournamentData.tournamentMatches;
                currentMatch = gameState.tournamentData.currentMatch;
                tournamentRound = gameState.tournamentData.tournamentRound;
                updateTournamentDisplay();
            }

            updatePlayerNames();
            updateScores();
            showNotification(`Game loaded: "${saveName}"!`, 'success');
        }

        function deleteSave() {
            const saveName = document.getElementById('load-select').value;
            if (!saveName) {
                showNotification('Select a save to delete!', 'error');
                return;
            }

            if (!confirm(`Delete save "${saveName}"?`)) return;

            const saves = JSON.parse(localStorage.getItem('ticTacToeSaves') || '{}');
            delete saves[saveName];
            localStorage.setItem('ticTacToeSaves', JSON.stringify(saves));

            updateLoadOptions();
            showNotification(`Save "${saveName}" deleted!`, 'success');
        }

        function updateLoadOptions() {
            const select = document.getElementById('load-select');
            const saves = JSON.parse(localStorage.getItem('ticTacToeSaves') || '{}');
            
            select.innerHTML = '<option value="">Load game...</option>';
            
            Object.keys(saves).sort().forEach(saveName => {
                const option = document.createElement('option');
                option.value = saveName;
                option.textContent = `${saveName} (${new Date(saves[saveName].timestamp).toLocaleDateString()})`;
                select.appendChild(option);
            });
        }

        function exportData() {
            const saves = JSON.parse(localStorage.getItem('ticTacToeSaves') || '{}');
            const exportData = {
                saves,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `tic-tac-toe-saves-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showNotification('Save data exported!', 'success');
        }

        function importData() {
            const file = document.getElementById('import-file').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    if (importData.saves) {
                        const existingSaves = JSON.parse(localStorage.getItem('ticTacToeSaves') || '{}');
                        const mergedSaves = { ...existingSaves, ...importData.saves };
                        localStorage.setItem('ticTacToeSaves', JSON.stringify(mergedSaves));
                        updateLoadOptions();
                        showNotification(`Imported ${Object.keys(importData.saves).length} saves!`, 'success');
                    } else {
                        showNotification('Invalid save file format!', 'error');
                    }
                } catch (error) {
                    showNotification('Error reading save file!', 'error');
                }
            };
            reader.readAsText(file);
        }

        // Enhanced notification system
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // AI Logic - Advanced Minimax with Alpha-Beta Pruning
        function getAIMove() {
            switch(aiDifficulty) {
                case 'easy':
                    return getRandomMove();
                case 'medium':
                    return getMediumMove();
                case 'hard':
                    return getMinimaxMove(6); // Depth 6
                case 'impossible':
                    return getMinimaxMove(9); // Full depth
                default:
                    return getRandomMove();
            }
        }

        function getRandomMove() {
            const availableMoves = [];
            gameBoard.forEach((cell, index) => {
                if (cell === '') availableMoves.push(index);
            });
            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }

        function getMediumMove() {
            // 70% strategic, 30% random for medium difficulty
            if (Math.random() < 0.7) {
                return getMinimaxMove(3); // Shallow minimax
            } else {
                return getRandomMove();
            }
        }

        function getMinimaxMove(maxDepth) {
            const result = minimax(gameBoard, maxDepth, -Infinity, Infinity, true);
            return result.index;
        }

        function minimax(board, depth, alpha, beta, isMaximizing) {
            const scores = {
                'O': 10,  // AI wins
                'X': -10, // Human wins
                'tie': 0
            };

            const result = checkGameEnd(board);
            if (result !== null) {
                return { score: scores[result] };
            }

            if (depth === 0) {
                return { score: evaluateBoard(board) };
            }

            if (isMaximizing) {
                let maxEval = -Infinity;
                let bestMove = -1;

                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'O';
                        const evalScore = minimax(board, depth - 1, alpha, beta, false);
                        board[i] = '';

                        if (evalScore.score > maxEval) {
                            maxEval = evalScore.score;
                            bestMove = i;
                        }

                        alpha = Math.max(alpha, evalScore.score);
                        if (beta <= alpha) {
                            break; // Alpha-beta pruning
                        }
                    }
                }
                return { score: maxEval, index: bestMove };
            } else {
                let minEval = Infinity;
                let bestMove = -1;

                for (let i = 0; i < 9; i++) {
                    if (board[i] === '') {
                        board[i] = 'X';
                        const evalScore = minimax(board, depth - 1, alpha, beta, true);
                        board[i] = '';

                        if (evalScore.score < minEval) {
                            minEval = evalScore.score;
                            bestMove = i;
                        }

                        beta = Math.min(beta, evalScore.score);
                        if (beta <= alpha) {
                            break; // Alpha-beta pruning
                        }
                    }
                }
                return { score: minEval, index: bestMove };
            }
        }

        function checkGameEnd(board) {
            // Check for wins
            for (let condition of winningConditions) {
                const [a, b, c] = condition;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a];
                }
            }

            // Check for tie
            if (board.every(cell => cell !== '')) {
                return 'tie';
            }

            return null; // Game continues
        }

        function evaluateBoard(board) {
            let score = 0;

            // Evaluate each winning condition
            for (let condition of winningConditions) {
                score += evaluateLine(board, condition);
            }

            // Add positional bonuses
            score += getPositionalScore(board);

            return score;
        }

        function evaluateLine(board, [a, b, c]) {
            let score = 0;
            const line = [board[a], board[b], board[c]];
            
            const oCount = line.filter(cell => cell === 'O').length;
            const xCount = line.filter(cell => cell === 'X').length;
            const emptyCount = line.filter(cell => cell === '').length;

            if (oCount === 3) score += 100;      // AI wins
            else if (oCount === 2 && emptyCount === 1) score += 10;  // AI can win
            else if (oCount === 1 && emptyCount === 2) score += 1;   // AI potential

            if (xCount === 3) score -= 100;     // Human wins
            else if (xCount === 2 && emptyCount === 1) score -= 10; // Block human win
            else if (xCount === 1 && emptyCount === 2) score -= 1;  // Human potential

            return score;
        }

        function getPositionalScore(board) {
            let score = 0;
            
            // Center is most valuable
            if (board[4] === 'O') score += 3;
            else if (board[4] === 'X') score -= 3;

            // Corners are valuable
            const corners = [0, 2, 6, 8];
            corners.forEach(corner => {
                if (board[corner] === 'O') score += 2;
                else if (board[corner] === 'X') score -= 2;
            });

            // Sides are least valuable
            const sides = [1, 3, 5, 7];
            sides.forEach(side => {
                if (board[side] === 'O') score += 1;
                else if (board[side] === 'X') score -= 1;
            });

            return score;
        }

        async function makeAIMove() {
            if (!gameActive || currentPlayer !== 'O' || gameMode !== 'ai') return;

            // Add AI thinking indicator to a random cell
            const availableCells = document.querySelectorAll('.cell:not(.taken)');
            if (availableCells.length > 0) {
                const randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                const indicator = document.createElement('div');
                indicator.className = 'ai-thinking-indicator';
                indicator.textContent = '🤖';
                randomCell.style.position = 'relative';
                randomCell.appendChild(indicator);

                setTimeout(() => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                }, 1500);
            }

            document.getElementById('ai-thinking').style.display = 'block';
            
            // Realistic thinking time based on difficulty
            const thinkingTime = {
                'easy': 500 + Math.random() * 500,
                'medium': 800 + Math.random() * 700,
                'hard': 1200 + Math.random() * 1000,
                'impossible': 1500 + Math.random() * 1500
            };
            
            await new Promise(resolve => setTimeout(resolve, thinkingTime[aiDifficulty] || 1000));
            
            document.getElementById('ai-thinking').style.display = 'none';
            
            const aiMove = getAIMove();
            if (aiMove !== undefined && aiMove !== null) {
                // Add preview effect before making move
                const previewCell = document.querySelector(`[data-index="${aiMove}"]`);
                previewCell.classList.add('preview');
                
                setTimeout(() => {
                    previewCell.classList.remove('preview');
                    makeMove(aiMove + 1, true);
                }, 300);
            }
        }

        // Enhanced Animation Functions
        function createMoveTrail(x, y) {
            const trail = document.createElement('div');
            trail.className = 'move-trail';
            trail.style.left = x + 'px';
            trail.style.top = y + 'px';
            document.body.appendChild(trail);

            setTimeout(() => {
                if (trail.parentNode) {
                    trail.parentNode.removeChild(trail);
                }
            }, 1000);
        }

        function shakeBoard() {
            const board = document.getElementById('board');
            board.classList.add('shake');
            setTimeout(() => {
                board.classList.remove('shake');
            }, 500);
        }

        function createCelebration() {
            const celebration = document.createElement('div');
            celebration.className = 'celebration';
            
            // Create confetti
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = ['#ffd93d', '#ff6b6b', '#4ecdc4', '#a8e6cf', '#ff9f43'][Math.floor(Math.random() * 5)];
                confetti.style.animationDelay = Math.random() * 2 + 's';
                confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
                celebration.appendChild(confetti);
            }
            
            document.body.appendChild(celebration);
            
            setTimeout(() => {
                if (celebration.parentNode) {
                    celebration.parentNode.removeChild(celebration);
                }
            }, 4000);
        }

        function animateScore(scoreElement) {
            scoreElement.classList.add('score-animation');
            setTimeout(() => {
                scoreElement.classList.remove('score-animation');
            }, 800);
        }

        // Enhanced game logic with animations
        document.querySelectorAll('.cell').forEach(cell => {
            cell.addEventListener('click', (e) => {
                if (gameActive && !cell.classList.contains('taken')) {
                    const index = parseInt(cell.dataset.index);
                    
                    // Create move trail effect
                    const rect = cell.getBoundingClientRect();
                    const x = rect.left + rect.width / 2;
                    const y = rect.top + rect.height / 2;
                    createMoveTrail(x, y);
                    
                    makeMove(index + 1);
                }
            });
        });

        document.getElementById('move-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                makeMove();
            }
        });

        async function makeMove(position = null, isAIMove = false) {
            if (!gameActive) return;
            
            // Don't allow human moves during AI turn, but allow AI moves
            if (gameMode === 'ai' && currentPlayer === 'O' && !isAIMove) return;

            let movePosition;
            if (position !== null) {
                movePosition = position;
            } else {
                movePosition = parseInt(document.getElementById('move-input').value);
            }

            if (!movePosition || movePosition < 1 || movePosition > 9) {
                if (!isAIMove) {
                    showNotification('Please enter a number between 1 and 9!', 'error');
                    shakeBoard();
                }
                return;
            }

            const arrayIndex = movePosition - 1;

            if (gameBoard[arrayIndex] !== '') {
                if (!isAIMove) {
                    showNotification('That space is already taken! Choose another.', 'error');
                    shakeBoard();
                }
                return;
            }

            // Make the move
            gameBoard[arrayIndex] = currentPlayer;
            updateDisplay(arrayIndex);
            moveCount++;
            
            // Clear input only for human moves
            if (!isAIMove) {
                document.getElementById('move-input').value = '';
            }

            // Check for win or draw
            if (checkWin()) {
                highlightWinningCells();
                scores[currentPlayer.toLowerCase()]++;
                updateScores();
                
                const winnerName = currentPlayer === 'X' ? playerNames.x : playerNames.o;
                document.getElementById('game-result').innerHTML = 
                    `<span class="winner">${gameMode === 'ai' && currentPlayer === 'O' ? 'AI' : winnerName} Wins! 🎉</span>`;
                
                // Enhanced celebration
                createCelebration();
                
                // Animate score update
                const scoreElement = currentPlayer === 'X' ? 
                    document.getElementById('score-x') : 
                    document.getElementById('score-o');
                animateScore(scoreElement);
                
                // Handle tournament progression
                if (tournamentMode && tournamentMatches.length > 0) {
                    const matches = tournamentMatches.filter(m => m.round === tournamentRound);
                    const currentTournamentMatch = matches[currentMatch];
                    if (currentTournamentMatch) {
                        currentTournamentMatch.winner = winnerName;
                        currentMatch++;
                        
                        setTimeout(() => {
                            if (currentMatch >= matches.length) {
                                advanceToNextRound();
                            } else {
                                startNextMatch();
                            }
                        }, 3000); // Wait for celebration
                    }
                }
                
                showComboInfo();
                playWinSound();
                gameActive = false;
                return;
            }

            if (checkDraw()) {
                scores.draw++;
                updateScores();
                document.getElementById('game-result').innerHTML = `<span class="draw">It's a Draw! 🤝</span>`;
                
                // Animate draw score
                animateScore(document.getElementById('score-draw'));
                
                // Handle tournament draw - replay match
                if (tournamentMode && tournamentMatches.length > 0) {
                    setTimeout(() => {
                        showNotification('Draw! Replaying match...', 'info');
                        resetGame();
                    }, 2000);
                } else {
                    gameActive = false;
                }
                return;
            }

            // Switch players
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            const playerDisplay = document.getElementById('current-player');
            playerDisplay.textContent = currentPlayer;
            playerDisplay.className = currentPlayer.toLowerCase();

            // Trigger AI move if in AI mode and it's AI's turn
            if (gameMode === 'ai' && currentPlayer === 'O' && !isAIMove) {
                setTimeout(makeAIMove, 500);
            }
        }

        function updateDisplay(index) {
            const cell = document.querySelector(`[data-index="${index}"]`);
            cell.textContent = currentPlayer;
            cell.className = `cell taken ${currentPlayer.toLowerCase()}`;
        }

        function checkWin() {
            for (let condition of winningConditions) {
                if (condition.every(index => gameBoard[index] === currentPlayer)) {
                    winningCombo = condition;
                    return true;
                }
            }
            winningCombo = null;
            return false;
        }

        function highlightWinningCells() {
            if (winningCombo) {
                winningCombo.forEach(index => {
                    document.querySelector(`[data-index="${index}"]`).classList.add('winning');
                });
            }
        }

        function showComboInfo() {
            if (!winningCombo) return;
            
            const comboNames = {
                '0,1,2': 'Top Row Victory!',
                '3,4,5': 'Middle Row Victory!',
                '6,7,8': 'Bottom Row Victory!',
                '0,3,6': 'Left Column Victory!',
                '1,4,7': 'Center Column Victory!',
                '2,5,8': 'Right Column Victory!',
                '0,4,8': 'Diagonal Victory!',
                '2,4,6': 'Anti-Diagonal Victory!'
            };
            
            const comboKey = winningCombo.join(',');
            const comboName = comboNames[comboKey] || 'Victory!';
            document.getElementById('combo-display').textContent = `${comboName} (${moveCount} moves)`;
        }

        function checkDraw() {
            return gameBoard.every(cell => cell !== '');
        }

        function updateScores() {
            document.getElementById('score-x').textContent = scores.x;
            document.getElementById('score-o').textContent = scores.o;
            document.getElementById('score-draw').textContent = scores.draw;
        }

        function resetGame() {
            currentPlayer = 'X';
            gameBoard = ['', '', '', '', '', '', '', '', ''];
            gameActive = true;
            moveCount = 0;
            winningCombo = null;

            // Reset display
            document.querySelectorAll('.cell').forEach((cell, index) => {
                cell.textContent = index + 1;
                cell.className = 'cell';
            });

            const playerDisplay = document.getElementById('current-player');
            playerDisplay.textContent = 'X';
            playerDisplay.className = 'x';

            document.getElementById('game-result').textContent = '';
            document.getElementById('combo-display').textContent = '';
            document.getElementById('move-input').value = '';
            document.getElementById('ai-thinking').style.display = 'none';
        }

        function playWinSound() {
            // Enhanced win sound with multiple tones
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Play a chord progression
                const frequencies = [523.25, 659.25, 783.99]; // C, E, G major chord
                
                frequencies.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.1);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime + index * 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.1 + 0.5);
                    
                    oscillator.start(audioContext.currentTime + index * 0.1);
                    oscillator.stop(audioContext.currentTime + index * 0.1 + 0.5);
                });
            } catch (e) {
                // Audio not supported, silently continue
            }
        }

        // Initialize
        createParticles();
        updateScores();
        updateLoadOptions();
        
        // Add event listeners for player name updates
        document.getElementById('player-x-name').addEventListener('input', updatePlayerNames);
        document.getElementById('player-o-name').addEventListener('input', updatePlayerNames);
        
        // Recreate particles when window resizes
        window.addEventListener('resize', createParticles);
    </script>
</body>
</html> 